

这里记录一些辅助理解**Assimp**模型加载代码细节的知识点：![image-20241119134721689](D:\MyProjects\Cpp\learn_opengl\opengl\src\5.model_loading\assets\image-20241119134721689.png)

**Mesh**和**Face**：**Mesh**（网格）是Draw的基本单元，网格是一个单独的组件，例如人模型的头、身子、四肢都是网格，可以类比到UE中的静态网格体。**Face**是网格中的面元，本质就是**indices**，即我们将哪些顶点绘制成三角形面（或者四边形等），在一个正方体网格中会有多个三角形面元，**Mesh**和**Face**就是这样的关系。

一个网格体会包含:

1. **顶点（vector<Vertex>）**：每个`Vertex`会对应位置向量、法线向量、纹理坐标、tangent、bitangent等（后两者之后再说是什么）。
2. **indices（vector<unsigned int>）**：索引，即顶点按照什么样的索引顺序来组成Face。
3. **textures（vector<Texture>）**：一个网格体可能会应用多个纹理贴图**Texture**（一个材质**material**，材质和纹理的关系随后会讲）。
4. **MaterialIndex**：材质索引，一个网格体对应一个材质。

**Material**和**Texture**：

**纹理**是有类型的，主要包括：

- **Diffuse Texture（漫反射纹理）**：用于模拟物体表面的基本颜色和图案。
- **Specular Texture（高光纹理）**：用于模拟物体表面的高光区域。
- **Normal Texture（法线纹理）**：用于模拟物体表面的凹凸细节，而不改变几何形状。
- **Bump Texture（凹凸纹理）**：通过改变表面法线来模拟凹凸效果，与法线纹理类似，但效果较为简单。
- **Displacement Texture（位移纹理）**：用于实际改变物体的几何形状，模拟更精细的凹凸效果。

**材质**是定义物体表面光学属性的一组参数，这些参数决定了物体如何与**光相互作用**。材质通常包括**颜色、光泽度、透明度、反射率、折射率**等属性。

**材质和纹理的关系**：在计算机图形学中，材质（Material）可以被看作是纹理（Texture）和光反应参数（Lighting Parameters）的集合。

1. **光反应参数（Lighting Parameters）**：
   - 这些参数描述了材质对光的反应，包括：
     - **颜色（Color）**：材质的基本颜色。
     - **反射率（Reflectivity）**：材质反射光的能力。
     - **光泽度（Glossiness）或粗糙度（Roughness）**：影响光在表面上的散射程度，高光泽度或低粗糙度意味着更少的散射，产生更清晰的反射。
     - **透明度（Transparency）**：材质的透明程度。
     - **折射率（Refractive Index）**：光线穿过材质时的弯曲程度。
     - **金属度（Metalness）**：材质是否为金属，以及金属的类型。
     - **自发光（Emission）**：材质是否发出光。
2. **纹理（Texture）**：
   - 纹理是贴图到3D模型上的2D图像，用于增强材质的视觉细节和复杂性。纹理可以包括：
     - **漫反射纹理（Diffuse/Albedo Texture）**：定义材质的基本颜色和图案。
     - **法线纹理（Normal Texture）**：模拟表面的凹凸细节。
     - **高光纹理（Specular Texture）**：定义高光区域和光泽度。
     - **粗糙度纹理（Roughness Texture）**：定义表面的粗糙程度。
     - **金属度纹理（Metalness Texture）**：定义材质的金属感。
     - **环境光遮蔽纹理（Ambient Occlusion Texture）**：模拟光线遮挡效果。
     - **自发光纹理（Emission Texture）**：定义材质的自发光区域。

材质通过结合这些参数和纹理，可以模拟出各种不同的表面效果，从而在渲染时产生逼真的视觉效果。在实际应用中，材质的参数和纹理可以非常复杂，它们共同决定了物体在不同光照条件下的外观。

**Scene**：记录**所有**（注意，是**所有**）**Mesh**和**Material**，同时提供一个**根节点**指针。根节点会维护一部分**Mesh索引**，根节点的子节点又会维护一部分**Mesh索引**，但他们维护的只是索引，想要访问具体的**Mesh**数据，只能通过**Mesh索引**在**scene**的**Meshes[]**中查找。

为什么要使用这样的类似树的数据结构呢，主要考虑到下面这种使用场景：比如说scene维护了一个房子的整体环境（包括整个房子、单独的房间、零散的家具）的所有网格和材质数据，我们把这个房子（不包括房间和家具）定义为根节点，房间是房子的子节点、家具又是房间的子节点。房子对应一部分mesh索引和一个material索引，房间对应一部分mesh索引和一个material索引，家具也各自有各自的mesh索引和一个material索引。所有的mesh索引合起来会对应scene中mesh数组的长度，所有的material索引合起来会对应scene中material数组的长度。同时这种父子结构可以方便的实现这样的效果：我移动房子节点，那么房子节点的子节点（房间和家具）会跟着父节点同时移动。	

上面就是一些在理解assimp模型加载代码过程中困难的点，下面我大致整理一下Assimp模型加载的一个大致流程：

1. `importer.ReadFile(path) -> scene` : Assimp读取模型文件，将模型加载成最开始图片显示的这种数据结构。
2. `processNode(scene->mRootNode, scene)` ： 从根节点开始，递归深搜所有的节点，对于每个节点的`aiMesh`，将其中的数据处理封装（`processMesh`）成我们自定义的`Mesh`类。
3. `Model.Draw`: 本质上就是遍历模型所有的`Mesh`，并调用`Mesh`的`draw`。

突然发现思路好像就是这么简单，只不过里面有代码的很多细节，需要结合具体的代码来理解。